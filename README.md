# LearnCpp
记录一下学习的过程，修了技科的程设总感觉不往后面学点cpp有点亏了，有Python面向对象的基础应该比较快（吧？

## 2022/1/7 
学习到Chapter3
学会了一些Cpp的基本语法，大致和C很像，所以没有太大的难度，就是std的声明好麻烦，还有要include好多东西，好麻烦，不像Python要么把常用的东西都内置了，要么一个包整合了所有相关的东西，也许是我没设置好，以后再看看。

## 2022/1/8 
学习到
感觉这本教材讲的好混乱，虽然通过了实际的例子帮忙理解一些具体的东西，但是感觉知识没有形成一个体系。

## 2022/1/9
开摆

## 2022/1/10
把第四章的剩下的东西扫了个尾，随便挑了两道题做做，考虑后面在这里面记一点笔记，但是markdown的语法我并不熟悉，再说吧
C++好抽象啊。。。和当时学C一个接一个的体系完全不一样，甚至感觉笔记都没啥好做的

## 2022/1/11
开摆

## 2022/1/12
在外面玩

## 2022/1/13
总结一下第五章的东西
#### 顺序容器和string类型操作

```c++
container<T>::iterator
container<T>::const_iterator //表示这个容器的迭代器的类型名
container<T>::size_type //类型名称，用来保存这个容器可能存在的最大实例的长度

c.begin() 
c.end() //指向容器第一个元素和紧跟在最后一个元素之后的那个位置的迭代器
  
c.rbegin()
c.rend() //对于允许以逆序访问元素的容器，表示指向容器最后一个元素和位于第一个元素之前的那个位置的迭代器

container<T> c;
container<T> c(c2); //定义一个容器c，如果给定c2，则c是c2的一个复印件，否则c为空

contanier<T> c(n); //定义一个有n个元素的容器c，c根据T的类型而被数值初始化，如果T是一个类类型，那么这个类型将控制元素的初始化方式，如果T是一个内部算术类型，那么元素将被初始化为0

contanier<T> c(n,t); // 定义一个有n个元素的容器，c的元素是t的复件

contanier<T> c(b,e); //创建一个容器，保存了位于区间[b,e)中的迭代器所指示元素的一个复件

c.size() //返回c元素个数，返回类型是size_type
c.empty() // 用来指示c是否没有元素
c.insert(d,b,e) //复制位于区间[b,e)中的迭代器所指示元素，并把他们插入到c中位于d之前的位置中
c.erase(it)
c.erase(b,e) //从容器中删除由it指示或[b,e)指示的元素，对于表来说，指向被删除元素的迭代器会失效，而对向量和字符串，所有指向位于被删除元素之后的元素的迭代器都会失效
c.push_back(t) // 在c的末尾添加一个元素，元素的值为t
```

#### 迭代器操作

```c++
*it //间接引用迭代器it来获取存储在容器中位于it所指示的位置的值
it -> x //与(*it).x等价
```

#### string类型操作

```c++
s.substr(i,j) //创建一个新的字符串来保存s的在区间[i,i+j)中的索引所指示的字符串的一个复件
getline(is,s) //从is读一行并把它存储在s中
s+=s2 //用s+s2来代替s的值
```

#### vector类型操作

```c++
v.reverse(n) //保留空间以保存n个元素，但不影响元素初始化，仅仅影响向量为响应insert和push_back的重复调用而分配内存的频率
v.resize(n) //给v一个新长度，这个长度等于n，如果n比v当前长度小，那么在这个向量中位于位置n之后的元素会被删除掉，如果n比当前长度大，则会添加新的元素到向量中
```

#### list类型操作

```c++
l.sort()
l.sort(cmp) //利用<运算符来排列元素，或者用判定cmp来排列元素
```

#### cctype.h提供的有用函数

```c++
isspace(c) //如果c是一个空白字符则为真
isalpha(c) //如果c是一个字母则为真
isdigit(C) //如果c是一个数字则为真
isalnum(c) //如果c是一个字母或数字则为真
ispunct(c) //如果是标点则为真
isupper(c) //如果是大写字母则为真
islower(c) //如果是小写字母则为真
toupper(c) //产生一个等于c的大写字母
tolower(c) //产生一个等于c的小写字母
```